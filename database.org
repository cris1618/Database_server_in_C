#+TITLE: Database Server in C
#+AUTHOR: Cristian Del Gobbo (pledged)
#+STARTUP: overview hideblocks indent
#+PROPERTY: header-args:C :main yes :includes <stdio.h> <stdlib.h> <string.h> <unistd.h> <assert.h> <errno.h> :results output :noweb yes

* Implementing a Binary Tree
Define the structure of the three by creating Nodes, Leaves and the Tree
#+name: bin_tree
#+begin_src C 
  #define TagRoot 1 /* 00 01 */
  #define TagNode 2 /* 00 10 */
  #define TagLeaf 4 /* 01 00 */

  // Define a Null pointer
  typedef void* Nullptr;
  Nullptr nullptr = 0;

  // Macro for the function that find the last leaf (Only need to chage the Macro)
  #define find_last(x) find_last_linear(x)
  #define reterr(x) \			
  errno = (x); // Change error number to x
  return nullptr; // return a null pointer

  typedef unsigned int int32;
  typedef unsigned short int int16;
  typedef unsigned char int8;
  typedef unsigned char Tag;

  struct s_node{
    Tag tag; // Help keep track of the kind of structure
    struct s_node* north; // up link
    struct s_node* west; // left link
    struct s_leaf* east; // right link, only leaves
    int8 path[256]; // Contain the path
  };
  typedef struct s_node Node;

  struct s_leaf{
    Tag tag;
    union u_tree* west; // Connect to the left
    struct s_leaf* east;
    int8 key[128];
    int8* value; // Pointer to the value, allocate it separately
    int16 size; // size of the value
  };
  typedef struct s_leaf Leaf;

  union u_tree{ // All variable in the union share the same memory space
    Node n; // One Node or one Leaf, not both at the same time
    Leaf l;
  };
  typedef union u_tree Tree;

  #+end_src

#+RESULTS: bin_tree

Define the tree root
#+name: tree_root
#+begin_src C
  <<bin_tree>>
    // Create the root of the tree
  Tree root = {
      .n = { // Node
        .tag = (TagRoot | TagNode),
        .north = (Node *)&root, // Point to itself
        .west = 0,
        .east = 0,
        .path = "/"
      }
    };
#+end_src

#+RESULTS: tree_root

Function to create and link nodes
#+name: create_node
#+begin_src C
  <<tree_root>>

    // Create zero function
  void zero(int8* str, int16 size){
    int8* p;
    int16 n;

    for(n=0, p=str; n < size; p++, n++)
      ,*p = 0;

    return;
    }

  // Function to create node
  Node* create_node(Node* parent, int8* path){
    Node* n;
    int16 size;


    errno = NoError;
    assert(parent);
    n = (Node *)malloc((int)size);
    zero((int8 *)n, size);

    // Define the parent, pointing to this node
    parent -> west = n;

    // Initialize fields inside of n
    n->tag = TagNode;
    n->north = (Tree *)parent;
    strncpy((char *)n->path, (char *)path, 255);

    return n;
  }


  // Main function for testing purposes
  /*int main(){ 
    Node* n, *n2; 
    n = create_node((Node *)&root, (int8 *)"/Users");
    assert(n);
    n2 = create_node(n, (int8 *)"/Users/login");
    assert(n2);

    // Print addreses
    printf("Address of n: %p\n", &n);
    printf("Address of n2: %p\n", &n2);
    free(n2);
    free(n);
    return 0;
    }*/ 
#+end_src

#+RESULTS: create_node

Create a Leaf
#+name: create_leaf
#+begin_src C
  <<create_node>>

    // Function to find the last leaf
  Leaf* find_last_linear(Node* parent){ // Linear search for the moment
    Leaf* l;

    errno = NoError;
    assert(parent);

    if(!parent->east)
      reterr(NoError); // Return Error

    // Loop as long as l as an east "Brother"
    for(l = parent->east; l->east; l = l->east); // l will be the leaf on the last east position    
    assert(l);

    return l;
    }


  Leaf* create_leaf(Node* parent, int8* key, int16 count){
    Leaf* l, *new;
    Node* n;
    int16 size;


    assert(parent);
    l = find_last(parent); // last leaf
    size = sizeof(struct s_leaf);
    new = (Leaaf *)malloc(size);
    assert(new);

    if(!l) // Directly connected with the parent 
      parent->east = new;
    else
      // l is a leaf
      l->east = new;

    // Initialize fields of the leaf
    zero((int8 *)new, size);
    new->tag = TagLeaf;
    new->west = (!l) ? (Node *)parent : (Leaf *)l;




  }

#+end_src

#+RESULTS: create_leaf

