#+TITLE: Database Server in C
#+AUTHOR: Cristian Del Gobbo (pledged)
#+STARTUP: overview hideblocks indent
#+PROPERTY: header-args:C :main yes :includes <stdio.h> <stdlib.h> <string.h> <unistd.h> <assert.h> <errno.h> :results output :noweb yes

* Implementing a Binary Tree
#+name: bin_tree
#+begin_src C 
  #define TagRoot 1 /* 00 01 */
  #define TagNode 2 /* 00 10 */
  #define TagLeaf 4 /* 01 00 */

  typedef unsigned int int32;
  typedef unsigned short int int16;
  typedef unsigned char int8;
  typedef unsigned char Tag;

  struct s_node{
    Tag tag; // Help keep track of the kind of structure
    struct s_node* north; // up link
    struct s_node* west; // left link
    struct s_leaf* east; // right link, only leaves
    int8 path[256]; // Contain the path
  };
  typedef struct s_node Node;

  struct s_leaf{
    Tag tag;
    union u_tree* west; // Connect to the left
    struct s_leaf* east;
    int8 key[128];
    int8* value; // Pointer to the value, allocate it separately
    int16 size; // size of the value
  };
  typedef struct s_leaf Leaf;

  union u_tree{ // All variable in the union share the same memory space
    Node n; // One Node or one Leaf, not both at the same time
    Leaf l;
  };
  typedef union u_tree Tree;

  #+end_src

#+RESULTS: bin_tree

Define the tree root
#+name: tree_root
#+begin_src C
  <<bin_tree>>
  // Create the root of the tree
  Tree root = {
      .n = { // Node
        .tag = (TagRoot | TagNode),
        .north = (Node *)&root, // Point to itself
        .west = 0,
        .east = 0,
        .path = "/"
      }
    };
#+end_src

#+RESULTS: tree_root

Function to create and link nodes
#+name: create_node
#+begin_src C
  <<tree_root>>

    // Create zero function
  void zero(int8* str, int16 size){
    int8* p;
    int16 n;

    for(n=0, p=str; n < size; p++, n++)
      ,*p = 0;

    return;
    }

  // Function to create node
  Node* create_node(Node* parent, int8* path){
    Node* n;
    int16 size;

    assert(parent);
    n = (Node *)malloc((int)size);
    zero((int8 *)n, size);

    // Define the parent, pointing to this node
    parent -> west = n;

    // Initialize fields inside of n
    n->tag = TagNode;
    n->north = (Tree *)parent;
    strncpy((char *)n->path, (char *)path, 255);

    return n;
  }


  int main(){
    Node* n, *n2; 
    n = create_node((Node *)&root, (int8 *)"/Users");
    assert(n);
    n2 = create_node(n, (int8 *)"/Users/login");
    assert(n2);

    // Print addreses
    printf("Address of n: %p\n", &n);
    printf("Address of n2: %p\n", &n2);
    free(n2);
    free(n);
    return 0;
  }
#+end_src

#+RESULTS: create_node
: Address of n: 0x7ffe41d6c688
: Address of n2: 0x7ffe41d6c690
